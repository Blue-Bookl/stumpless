# Style de code Stumpless
Stumpless suit un style assez simple, bien qu'il ne soit pas un standard connu comme K&R. Comme la mise en forme du code n'est pas courante et même parfois incohérente, il y aura une certaine tolérance pour les changements qui ne la respectent pas parfaitement. Cela reste à la discrétion du relecteur de la pull request.

Voici quelques autres points de style à suivre dans la base de code :

 * **Aucune directive `#ifdef` n'est autorisée dans les fichiers source (`.c`).**
   Le code source avec des directives du préprocesseur qui ajoutent, modifient ou suppriment des fonctionnalités est facile à ajouter, mais disperse le comportement spécifique à la configuration et les dépendances de l'environnement de build dans les fichiers source, rendant le flux du programme plus difficile à comprendre. Ces extraits doivent plutôt être regroupés dans des modules de configuration séparés qui gardent le code de portabilité à l'écart des autres logiques et faciles à trouver, comprendre et modifier. Voir le [guide de portabilité](portability.md) pour plus de contexte sur cette décision et comment travailler avec cette limitation.
 * **Les espaces sont utilisés pour l'indentation (2 par niveau).**
   Nous savons que le débat "tabs vs. espaces" est sans fin. Merci de respecter la convention du projet et d'éviter l'utilisation des tabulations.
 * **Les éléments sont classés par ordre alphabétique dans les sections.** Les fonctions dans les fichiers d'en-tête et les cas de test sont les principaux concernés. Il y a des cas où l'ordre alphabétique rend quelque chose moins clair, et dans ces cas il est bien sûr préférable d'utiliser l'ordre le plus clair. Mais par défaut, insérez toujours les éléments par ordre alphabétique sauf raison contraire.

## Conventions de nommage
Il existe quelques préfixes, suffixes et autres standards de nommage suivis dans les fonctions et variables du code source. Les comprendre vous aidera à suivre la logique du code et à choisir les noms dans vos propres ajouts.

 * **Préfixe `stumpless_`** Les fonctions et types fournis par la bibliothèque commencent presque tous par `stumpless_` pour minimiser les conflits de noms avec les utilisateurs de la bibliothèque. Il y a quelques exceptions (comme `stump` et `stumplog`), mais en général, si vous créez une nouvelle fonction publique, elle doit commencer par ce préfixe.
 * **Préfixe `config_`** Les fonctions commençant par `config_` dépendent de la configuration de build du projet. Elles peuvent pointer vers une fonction différente selon la plateforme ou les options de compilation, mais gardent toujours la même sémantique. Voir le [guide de portabilité](portability.md) pour plus d'informations sur la gestion de la portabilité dans les noms de fonctions et d'en-têtes.
 * **Préfixe `locked_`** Les fonctions commençant par `locked_` supposent que certains ou tous leurs paramètres sont protégés par un mutex avant d'être appelés. Elles ne sont pas thread-safe par elles-mêmes, c'est donc à l'appelant de verrouiller les ressources. Ces fonctions sont utiles lorsqu'une opération doit être effectuée, mais qu'utiliser une version thread-safe provoquerait un deadlock en essayant d'obtenir un mutex déjà détenu. Souvent, la version sans préfixe `locked_` acquiert simplement les verrous puis appelle la version `locked_`.
 * **Préfixe `unchecked_`** Certaines fonctions commencent par `unchecked_` pour indiquer qu'elles ne vérifient pas leurs arguments. Cela permet d'éviter des vérifications redondantes si elles ont déjà été faites ailleurs. L'appelant doit alors s'assurer que les vérifications nécessaires sont faites avant d'appeler ces fonctions.
 * **Suffixe `_w`** Les fonctions avec un suffixe `_w` prennent des chaînes de caractères larges en UTF-16, au lieu des chaînes multioctets UTF-8 standard. Ces fonctions facilitent l'utilisation sous Windows, où les chaînes larges sont parfois la norme. Le suffixe est similaire à la distinction 'A' vs. 'W' dans les fonctions Windows, mais ici stumpless utilise des chaînes multioctets ailleurs, pas juste ASCII !
 * **Suffixe `_str`** Pour les fonctions qui supportent les spécificateurs de format, il existe souvent une version avec `_str` à la fin. Ces fonctions sont identiques à la version avec format, mais ne prennent qu'une seule chaîne. Les fonctions `_str` nécessitent moins d'analyse et présentent moins de risques de sécurité, il est donc préférable de les utiliser dès que possible.
 * **Constructeurs `new` et destructeurs `destroy`** Les constructeurs avec "new" dans le nom, comme `stumpless_new_entry`, allouent la mémoire pour une nouvelle structure et la retournent après initialisation. Les structures créées ainsi doivent être détruites avec les destructeurs "destroy", comme `stumpless_destroy_entry_and_contents`.
 * **Constructeurs `load` et destructeurs `unload`** Les constructeurs avec "load" font la même initialisation que les "new", mais au lieu d'allouer dynamiquement la mémoire, ils remplissent une structure fournie en paramètre. C'est souvent plus rapide, car il y a moins d'allocations dynamiques. Les structures initialisées ainsi doivent être détruites avec les destructeurs "unload". Un exemple est le couple `stumpless_load_entry` et `stumpless_unload_entry`.
 * **Constructeurs `open`** Les fonctions utilisant "open" au lieu de "new" ou "load" font la même chose qu'un constructeur "new", mais passent aussi la structure à l'état ouvert. Actuellement, seuls les cibles réseau peuvent être dans un état autre qu'ouvert, si la connexion avec le point de log n'est pas active.
